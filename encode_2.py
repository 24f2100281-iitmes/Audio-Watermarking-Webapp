# -*- coding: utf-8 -*-
"""Encode-2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1e1YxmR3BcQSqFwV22IjcsQeLy2CiXOTT
"""

import numpy as np
import librosa
import soundfile as sf
from google.colab import files

print("="*60)
print("AUDIO WATERMARKING - ENCODING (FFT BASED)")
print("="*60)

# Step 1: Upload Audio Files
print("\nğŸ“ Please upload the ORIGINAL audio file:")
orig_upload = files.upload()
original_file = list(orig_upload.keys())[0]
print(f"âœ“ Original audio loaded: {original_file}")

print("\nğŸ“ Now upload the WATERMARK audio file:")
wm_upload = files.upload()
watermark_file = list(wm_upload.keys())[0]
print(f"âœ“ Watermark audio loaded: {watermark_file}")

# Step 2: Load and preprocess audio
print("\nâš™ï¸ Loading and preprocessing audio files...")

def load_audio(file_path):
    data, sr = librosa.load(file_path, sr=None, mono=True)
    return data, sr

orig, sr1 = load_audio(original_file)
wm, sr2 = load_audio(watermark_file)

print(f"  Original audio: {len(orig)} samples @ {sr1} Hz")
print(f"  Watermark audio: {len(wm)} samples @ {sr2} Hz")

# Match sample rate
if sr1 != sr2:
    wm = librosa.resample(wm, orig_sr=sr2, target_sr=sr1)
    print(f"  âœ“ Resampled watermark to {sr1} Hz")

# Match length
if len(wm) > len(orig):
    wm = wm[:len(orig)]
else:
    wm = np.pad(wm, (0, len(orig) - len(wm)))

# Step 3: FFT Transform
print("\nğŸ”„ Performing FFT...")

FFT_orig = np.fft.fft(orig)
FFT_wm = np.fft.fft(wm)

# Step 4: Embed watermark in high-frequency region
print("\nğŸ” Embedding watermark into high-frequency FFT bins...")

alpha = 0.008  # embedding strength
N = len(FFT_orig)

# High-frequency band selection (last 25%)
start = int(0.7 * N)

FFT_watermarked = FFT_orig.copy()
FFT_watermarked[start:] += alpha * FFT_wm[start:]

print(f"  Embedding factor (alpha): {alpha}")
print(f"  âœ“ Watermark embedded in FFT high-frequency region")

# Step 5: Inverse FFT
print("\nğŸ”¨ Reconstructing watermarked audio...")

watermarked_audio = np.fft.ifft(FFT_watermarked)
watermarked_audio = np.real(watermarked_audio)

# Normalize
watermarked_audio /= np.max(np.abs(watermarked_audio))

print("  âœ“ Audio reconstructed and normalized")

# Step 6: Save output
output_file = "watermarked_audio_fft.wav"
sf.write(output_file, watermarked_audio, sr1)

print(f"\nâœ… Watermarked audio saved as '{output_file}'")

# Step 7: Download result
print("\nğŸ“¥ Downloading watermarked audio...")
files.download(output_file)

print("\n" + "="*60)
print("âœ“ FFT-BASED ENCODING COMPLETE!")
print("="*60)